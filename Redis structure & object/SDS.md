## SDS(Simple Dynamic String)

SDS是Redis的一种数据结构，实现底层对于字符串的存储和相关的操作，Redis的每一个字符串对象在底层作为一个SDS存在。

### Samples

```python
set msg "hello world"
```

键：键msg，是字符串"msg"，其在底层作为一个SDS结构存在。

值：值"hello world"，在底层依旧作为一个SDS结构存在。

```python
rpush students "Alice" "Bob" "Cherli"
```

该列表对象的键students，是字符串"students"，其在底层作为一个SDS结构存在。

其值是一个列表，列表中的三个字符串在底层分别被作为SDS结构存在。

### SDS的结构

每一个sds.h/sdshdr结构表示一个SDS值：

```C
struct sdshdr{
    // 记录buf数组中已使用字节的数量
    // 等于SDS所保存的字符串的长度
    int len;
    // 记录buf数组中未使用字节的数量
    int free;
    // 字节数组buf, 用于保存字符串
    char buf[];
}
```

### 于C语言字符串，使用SDS的原因？

A. SDS可以以常数复杂度获取字符串长度，避免了获取字符串长度成为Redis的性能瓶颈。

SDS中有len、free属性，用来记录SDS中字符串的长度以及未使用字节的长度，可以在复杂度为O(1)的情况下获取字符串长度，并且len、free的属性是在API调动时完成更新；而C语言要获取字符串的长度只能够通过遍历字符串的方式来获取，其复杂度为O(N)；

B. 杜绝缓冲区溢出问题。

1. C语言字符串通过`strcat(char *dest, char *src);`函数进行字符串拼接时，不会对dest串的空间进行检查，如果dest后面相邻的地址存有其他的字符串，则会被src覆盖，即发生了缓冲区溢出。
2. SDS中的字符串在使用`sdscat`拼接的过程中，`sdscat`函数会对其进行空间检查，若空间不足，则会根据**内存分配策略**分配内存，然后进行拼接，从而避免了缓冲区溢出问题。

C. SDS减少了内存分配的次数，性能优于C语言字符串。

1. C语言字符串在每次**增长**操作时，都要分配一次内存，所以其进行N次增长操作，必分配N次内存。
2. SDS在字符串增长操作时，会根据内存分配策略分配多余的一部分内存，避免了每次都要分配内存，所以SDS最多分配N次内存。

D.  SDS可以存储二进制数据，而C语言字符串只能存储文本数据，SDS实现了二进制安全。

1. 由于C语言是以结尾的空字符`'\0'`来判断字符串的结束，所以，字符串中间不能存储空字符`'\0'`，这个特性决定了C语言不能存储二进制文件。
2. SDS与C语言一样是以空字符`'\0'`结尾，但是SDS并不以空字符`'\0'`判断字节数组的结束，而是通过属性free、len来判断字节数组的结束与否，所以SDS可以以一种安全的方式存储二进制文件，并且Redis的API都是以二进制的处理方式来处理数据。

E. SDS兼容了C语言<string.h>库中的函数。

SDS以`'\0'`结尾的目的是可重用C语言的字符串函数，避免了书写重复代码。

### SDS的空间分配策略

SDS的空间分配策略是针对于字符串动态改变其长度的一种内存分配策略。

1. 空间预分配策略
   * 在len小于1M时，根据空间分配策略会分配一定的未使用内存给SDS，其大小由free记录，与len的大小相等。
   * 在len大于1M时，根据空间分配策略会分配1M的内存给SDS。
   * 注意：free的值不是固定的，在分配内存(size)给free时，当前free=free+size。
2. 惰性内存释放

> 惰性内存释放会产生内存的浪费或者内存泄露的问题吗？不会，Redis具有释放SDS内存的API，所以在不需要的时候，可以释放。
